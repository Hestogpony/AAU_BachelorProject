\subsection{Linear Programming Approach}
The first solution model we propose for finding the fastest path between two points in a road network is based on a linear programming approach. 
The algorithm consists of continuous pruning of paths in the road network, until we end up with a single path which is the optimal one. Initially, we pick a random path from $s$ to $t$, called $p$, and solve it optimally, which returns time $T_p$. For every other paths, $p'_i$, from $s$ to $t$ in the road network, we calculate the time it takes to pass it at maximum speed and without charging, which returns time $T_{p'_{i}}$. If $T_p \leq T_{p'_{i}}$ for any $p'_{i}$, we simply ignore it and all it's sub-paths. We can do this, since the optimally time spend driving $p'_i$ will be either greater than or equal to $T_{p'_{i}}$. If we find a path which can be driven faster than $T_p$ we update $p$ and $T_{p'}$. Determining how a path is optimally solved is described in section \ref{sec:optimizingwithLP}. But the overall algorithm for finding the fastest path looks as follows:\\

\begin{algorithmic}
\Function{fastestPath}{$G,s,t$}
    \State $p \gets$ initial\_path($G,s,t$) 
    \State $T_p \gets$ solve\_optimally($p$)
    \State $potential\_paths \gets$ get\_paths($G,s,t,T_p$)
    \Repeat 
    	\State $T_{p_1} \gets$ solve\_optimally(potential\_paths[1])
    	\If{$T_{p_1} < T_p$} 
    		\State $T_p \gets T_{p_1}$
    		\State $p \gets potential\_paths[1]$ 
    	\EndIf  
    	\State $paths.remove(potential\_paths[1])$
    	\ForAll{$p \in potential\_paths$} 
    		\If{$T_p \leq p.min$}
    			\State $potential\_paths.remove(p)$
    		\EndIf
    	\EndFor
    \Until{$potential\_paths.size = 0$}
    \State \Return $(p, T_p)$
\EndFunction
\end{algorithmic}

$initial\_path(G,s,t)$ returns a randomly chosen path, $p$ which is solved optimally by $solve\_optimally(p)$. $get\_paths(G,s,t,T_p)$ returns a sorted list of paths in $G$ between $s$ and $t$ with a max travelling time of $T_p$.

