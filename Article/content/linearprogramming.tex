\subsection{Global optimal solution}
The nature of the optimisation problem proposed in \Cref{sec:optiprob} is a non linear optimization problem, due to the $\frac{D(e_i)}{v_{e_i}}$ and $R_{CO}(v_{e_i})$ being non linear. The problem can however be reformulated into a linear programming problem by piecewice-linear functions $(1)$, this section reformulates the optimization problem as a linear programming problem. More precisely the problem is modeled as a in  
This optimisation problem is almost a linear programming problem. However, we suffer from a non-linear constraint: $D(e_i)*R_{CO}(v(e_i))$ since the consumption rate $R_{CO}(v(e_i))$ of the EV is not linear. The function can however be estimated using linearisation. 

subject to: 
\begin{equation}
\forall_{i\in1 \dots n }:\; \sum_{j=1}^{m} Selectedlines[i,j] = 1
\end{equation}

\begin{equation}
\forall_{i\in1 \dots n, j \in 1 \dots m}: \; \;0\leq Selectedlines[i,j] \leq 1
\end{equation}

\begin{equation}
\forall_{i\in1 \dots n, j \in 1 \dots m}:\; v(e_i) \le Selectedlines[i,j] * Points1[i,j]
\end{equation}

\begin{equation}
\forall_{i\in1 \dots n, j \in 1 \dots m}:\; v(e_i) \ge Selectedlines[i,j] * Points2[i,j]
\end{equation}

\begin{equation}
\begin{split}
\forall_{k\in1 \dots n}\;:\;0 \le\sum_{i=1}^{k}chargerate[i]*charge[i]\\
-\sum_{i=1}^{k} distance[i](\sum_{j=1}^{m} LinesA[i,j]*speed[i,j]\\
+\sum_{j=1}^{m} Selectedlines[i,j]*LinesB[i,j]) \le maxbattery\;capacity
\end{split}
\end{equation}

The first solution model we propose for finding the fastest path between two points in a road network is based on a linear programming approach. 
The algorithm consists of continuous pruning of paths in the road network, until we end up with a single path which is the optimal one. Initially, we pick a random path from $s$ to $t$, called $p$, and solve it optimally, which returns time $T_p$. For every other paths, $p'_i$, from $s$ to $t$ in the road network, we calculate the time it takes to pass it at maximum speed and without charging, which returns time $T_{p'_{i}}$. If $T_p \leq T_{p'_{i}}$ for any $p'_{i}$, we simply ignore it and all it's sub-paths. We can do this, since the optimally time spend driving $p'_i$ will be either greater than or equal to $T_{p'_{i}}$. If we find a path which can be driven faster than $T_p$ we update $p$ and $T_{p'}$. Determining how a path is optimally solved is described in section \ref{sec:optimizingwithLP}. But the overall algorithm for finding the fastest path looks as follows:\\

\begin{algorithmic}
\Function{fastestPath}{$G,s,t$}
    \State $p \gets$ initial\_path($G,s,t$) 
    \State $T_p \gets$ solve\_optimally($p$)
    \State $potential\_paths \gets$ get\_paths($G,s,t,T_p$)
    \Repeat 
    	\State $T_{p_1} \gets$ solve\_optimally(potential\_paths[1])
    	\If{$T_{p_1} < T_p$} 
    		\State $T_p \gets T_{p_1}$
    		\State $p \gets potential\_paths[1]$ 
    	\EndIf  
    	\State $paths.remove(potential\_paths[1])$
    	\ForAll{$p \in potential\_paths$} 
    		\If{$T_p \leq p.min$}
    			\State $potential\_paths.remove(p)$
    		\EndIf
    	\EndFor
    \Until{$potential\_paths.size = 0$}
    \State \Return $(p, T_p)$
\EndFunction
\end{algorithmic}

$initial\_path(G,s,t)$ returns a randomly chosen path, $p$ which is solved optimally by $solve\_optimally(p)$. $get\_paths(G,s,t,T_p)$ returns a sorted list of paths in $G$ between $s$ and $t$ with a max travelling time of $T_p$.

%sources
%1, SWP-3587
%
%
%
%
%


