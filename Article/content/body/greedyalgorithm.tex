\subsection{Greedy Algorithm}
By continuously picking the currently fastest path, and keep it updated throughout the graph we can find the fastest path. A locally best choice is to select the minimum of driving using the energy in the battery or charge and drive.
The time spent driving an edge $(u_1, u_2)$ in the graph, when driving and charging is given by the following equation:
\begin{equation}
\begin{aligned}
 & T(v,(u_1, u_2)) = \frac{D(u_1, u_2)}{v} + \frac{CS(v) * D(u_1, u_2) - B_{cur}}{u_1.preCH_0()}
\end{aligned}
\end{equation}\label{eq:drivingAndCharging}

\begin{tikzpicture}
\begin{axis}[xlabel=velocity, ylabel=time]
\addplot[draw=red,domain=0:200]{(5/x)+(((0.0286*x^2 + 0.4096*x + 107.57)*5)/5000)};
\addplot[draw=black,domain=25:75]{0.295};
% \addplot[mark=*, domain=25:75] coordinates {(37,295)};
\end{axis}
\end{tikzpicture}

where $v$ is the speed of the vehicle, $D(u_1, u_2)$ is the distance between $u_1$ and $u_2$,
$CS(v)$ is the consumption rate of the vehicle at the speed $v$, $B_{cur}$ is the current battery of the vehicle and $preCH_0(u_1)$ is the charge rate of best charge station previous to $u_2$, which still can be used with overcharging the battery at that station. The above equation yields a function on the form: $av^2 + bv + d/v + c$, due to the fact that $\textbf{CS(v)}$ is a quadratic function \ref{eq:chargingFunc} and the values: $v, CS(v), u_1.preCH_0()$ all being positive.
A, b, c and d are some constants. Represented in a coordinate system, this becomes a curve as represented in figure X. On the x-axis is the speed of the vehicle and on the y-axis is the time spent.

The turning point of the graph, $v_{opt}(e)$, is the optimal speed for the EV this point is easily solved by finding a tangent line with a slope of 0. If $v_{opt}(e)$ is smaller than $v_{min}(e)$, $v_{min}(e)$ defines the optimal speed on road segment $e$ similarly if $v_{opt}(e)$ is larger than $v_{max}(e)$, $v_{max}(e)$ defines the optimal speed.  

The time spent driving an edge $(u_1, u_2)$ using the energy in the battery can be found by solving $B_{cur} - D(u_1, u_2) * CS(v) = 0$, if $v_{opt}(e)$ is lower than $v_{min}(e)$ the time used driving is set to infinity, since there is not enough energy in the battery the drive from $u_1$ to $u_2$, otherwise $v_{opt}$ is decided in the same way when charging is considered.   

The above can do used to create a function, which help us find the optimal way to drive a road segment. 
\[travel\_time(charge\_stations, (u_1, u_2), curbat) \]
we have a way of deciding the time it will take to drive a road segment, while accounting for the need of charging along the path. This function can be used in a modified version of Dijkstra's algorithm where we use time instead of distance. Just like Dijkstra's algorithm we keep track of the fastest path leading to each vertices, where fastest path means the path using less time, furthermore the previous charging stations which are still can be used for charging needs to be tracked, this way we can still charge at a station after leaving it if we do not violate the physical constraints in the system(no over charging). Lastly the algorithm needs to keep track of how much battery the EV have when it arrives at each charging station. Using this we can define a fastest path algorithm in the following way: 

\begin{algorithmic}
\Function{fastestPath}{$G,s,t$}
	\ForAll{$v \in G.V$} 
    		\State $v.time = infinity$
		\State $v.path = [v]$
    		\State $v.preCH = []$
		\State $v.myCH = [batCap, v.charge\_speed]$
		\State $v.B_{cur} = 0$
    	\EndFor
	\State $s.time = 0$
	\State $s.B_{cur} = initialBattery$
	\State $s.preCS.append(s.myCS)$	
	\State $Q = G.V sorted by time$
	\While{Q} 
		\State $u = Q[0]$
		\State $Q.remove[u]$
		\If{$u.time == infinity$} break \EndIf
		\ForAll{$neighbor v of u$} 
			\State $travel = travel\_time(u.preCS, (u, v), B_{cur})$
			\State $time = travel[1]$
			\State $preCS = travel[2]$
			\State $B_{cur} = travel[3]$
			\If{t$ime == infinity$} break \EndIf
			\If{$v.time > u.time + time$} 
				\State $v.time = u.time + time$
				\State $v.path = u.path + [v]$
				\State $v.B_{cur} = curbat$
				\State $v.preCS = cleanCS(preCS, u.myCS, burbat)$
				\State reposition $v$ in $Q$
			\EndIf

		\EndFor
	\EndWhile
	\State \Return $t.time, t.path$
\EndFunction
\end{algorithmic}\label{alg:fastest_path}

\subsubsection{Charge Station Cleanup}
While the algorithm progresses through the graph, it need to maintain only a subset of all the visited charge stations, as the battery capacity and therefore range of the vehicle is limited. At every charge station the algorithm reaches, we record the current battery and the charge station's charge rate as a tuple (bat_cur, CR(vertex)). cur_bat is the battery charge of the vehicle at the moment the vehicle reached that charge station, CR(vertex) is the charge rate of the vertex of the charge station.\\
\\
We maintain this subset of tuples by managing a list of tuples only with bat_cur lower than the vehicles max battery capacity. This will of course always be the case when we reach a charge station, but as we progress through the graph and some distance is being traveled, an extra amount of energy is needed. We add more energy to the system by increasing the bat_cur in all the tuple of the charge stations in the list. The first tuple in the list will always be the the charge station with the best charge rate. If at some point the bat_cur, of the tuple with the best charge rate, reaches bat_cap then we remove that tuple. When a tuple is removed we also remove every tuple, between the first and the second best charge rate in the list. Finally, if we at some point find a charge station with a charge rate better than every recorded charge rate, i.e. the first tuple, we delete all the tuples and add the current vertex.