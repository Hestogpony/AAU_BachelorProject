\subsection{Greedy-Heuristics-Approach}
\todo[inline]{klarlÃ¦g og beskriv den anvendte datastruktur}
Using Dijkstra's approach to a shortest path, where we propagate the weights throughout the graph, together with a look-back technique, we present a greedy-heuristic algorithm that continuously pick the currently and locally fastest path and propagate the time on that path throughout the graph.\\

The time spent driving an edge $(u_1, u_2)$ in the graph, when driving and charging, is given by the following equation:
\begin{equation}
\begin{aligned}
 & T(v,(u_1, u_2)) = \frac{D(u_1, u_2)}{v} + \frac{CS(v) * D(u_1, u_2) - B_{cur}}{preCH_0(u_1)}
\end{aligned}
\end{equation}\label{eq:drivingAndCharging}

\begin{figure}[!htb]
\begin{tikzpicture}
\begin{axis}[xlabel=velocity, ylabel=time,legend style={legend pos=north west}]
\addplot[draw=red,domain=0:200]{(5/x)+(((0.0286*x^2 + 0.4096*x + 107.57)*5)/5000)};
\addlegendentry{$\frac{5}{x}+\frac{(0.029*x^2 + 0.41*x + 107.57)*5}{5000}$}

\addplot[draw=black,domain=25:75]{0.295};
% \addplot[mark=*, domain=25:75] coordinates {(37,295)};
\end{axis}
\end{tikzpicture}% 
\caption{In this instance of $T(v,(u_1, u_2))$, going from $u_1$ to $u_2$, we have a distance of 5 miles and a chargespeed of 5kW on $u_1$. The optimal speed in this case is 42.12, which takes 25.2 minutes}
\end{figure}\label{fig:graph}

where $v$ is the speed of the vehicle, $D(u_1, u_2)$ is the distance between $u_1$ and $u_2$,
$CS(v)$ is the consumption rate of the vehicle at the speed $v$, $B_{cur}$ is the current battery of the vehicle and $preCH_0(u_1)$ is the charge rate of best charge station previous to $u_1$, which still can be used without overcharging the battery at that station. The above equation yields a function on the form: $av^2 + bv + c$, due to the fact that Equation \ref{eq:chargingFunc} is a quadratic function and the values: $v, CS(v), u_1.preCH_0()$ all being positive.
A, b and c are some constants. Represented in a coordinate system, this becomes a curve as represented in figure \ref{fig:graph}. On the x-axis is the speed of the vehicle and on the y-axis is the time spent.

The turning point of the graph, $v_{opt}(e)$, is the optimal speed for the EV this point is easily solved by finding a tangent line with a slope of 0. If $v_{opt}(e)$ is smaller than $v_{min}(e)$, $v_{min}(e)$ defines the optimal speed on road segment $e$ similarly if $v_{opt}(e)$ is larger than $v_{max}(e)$, $v_{max}(e)$ defines the optimal speed.  

The time spent driving an edge $(u_1, u_2)$ using the energy in the battery can be found by solving $B_{cur} - D(u_1, u_2) * CS(v) = 0$, if $v_{opt}(e)$ is lower than $v_{min}(e)$ the time used driving is set to infinity, since there is not enough energy in the battery to drive from $u_1$ to $u_2$. Otherwise $v_{opt}$ is decided in the same way when charging is considered.   

The above can do used to create a function, which help us find the optimal way to drive a road segment. 
\[travel\_time(charge\_stations, (u_1, u_2), curbat) \]
we have a way of deciding the time it will take to drive a road segment, while accounting for the need of charging along the path. This function can be used in a modified version of Dijkstra's algorithm where we use time instead of distance. Just like Dijkstra's algorithm we keep track of the fastest path leading to each vertices, where fastest path means the path using less time, furthermore the previous charging stations which are still can be used for charging needs to be tracked, this way we can still charge at a station after leaving it if we do not violate the physical constraints in the system(no over charging). Lastly the algorithm needs to keep track of how much battery the EV have when it arrives at each charging station. Using this we can define a fastest path algorithm in the following way: 

\begin{algorithmic}
\Function{fastestPath}{$G,s,t$}
	\ForAll{$v \in G.V$} 
    		\State $v.time = infinity$
		\State $v.path = [v]$
    		\State $v.preCH = []$
		\State $v.myCH = [batCap, v.charge\_speed]$
		\State $v.B_{cur} = 0$
    	\EndFor
	\State $s.time = 0$
	\State $s.B_{cur} = initialBattery$
	\State $s.preCS.append(s)$	
	\State $Q = G.V sorted by time$
	\While{Q} 
		\State $u = Q[0]$
		\State $Q.remove[u]$
		\If{$u.time == infinity$} break \EndIf
		\ForAll{$adj(u)$} 
			\State $travel = travel\_time(u.preCS, (u, v), B_{cur})$
			\State $time = travel[1]$
			\State $preCS = travel[2]$
			\State $B_{cur} = travel[3]$
			\If{t$ime == infinity$} break \EndIf
			\If{$v.time > u.time + time$} 
				\State $v.time = u.time + time$
				\State $v.path = u.path + [v]$
				\State $v.B_{cur} = curbat$
				\State $v.preCS = cleanCS(preCS, u, burbat)$
				\State reposition $v$ in $Q$
			\EndIf

		\EndFor
	\EndWhile
	\State \Return $t.time, t.path$
\EndFunction
\end{algorithmic}\label{alg:fastest_path}

\subsubsection{Charge Station Cleanup}
\todo[inline]{dette afsnit skal formentlig op til introduktionen af alg.}
While the algorithm progresses through the graph, it need to maintain only a subset of all the visited charge stations, as the battery capacity and therefore range of the vehicle is limited. At every charge station the algorithm reaches, we record the possible energy we can add at the charge station and the charge rate of the station as a tuple $(B_{possible}, CR(vertex))$.
\\
\\
We maintain this subset of tuples by managing a list of tuples only with $B_{possible}$ higher than 0. This will of course always be the case when we reach a charge station, but as we progress through the graph and some distance is being traveled, the possible energy at each previous charge station decreses. The first tuple in the list will always be the the charge station with the best charge rate. When a tuple is removed we also remove every tuple, between the first and the second best charge rate in the list. Finally, if we at some point find a charge station with a charge rate better than every recorded charge rate, i.e. the first tuple, we delete all the tuples.