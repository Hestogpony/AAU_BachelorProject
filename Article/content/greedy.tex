\subsection{Greedy Heuristics Algorithm}
\todo[inline]{introductory text}

\subsubsection*{Idea outline}
The idea of the approach taken in this section, is using Dijkstra's algorithm for finding the shortest path with $\frac{distance}{speed}$ as the weight of an edge. The problem then becomes, which speed must we use in the interval of $v_{min}$ and $v_{max}$. As argued previously, the optimal speed to drive can only be found by iterating over all possibilities which is a combinatorial optimization problem, and it is NP-Hard. Thus we introduce a heuristic, which promotes local optimal choices. This gives a fast path, but this might not be drivable, if there are not any charge stations on this path, thus we will need to figure out how to incorporate this.\\

We will now analyse how the weight can be found, specifically the speed. The time spent passing an edge $e = (u_1, u_2)$ in the road network, is given by the following equation:
\begin{equation*}
\begin{aligned}
 & T(v,(u_1, u_2)) = \frac{D((u_1, u_2))}{v} + \frac{R_{CO}(v) * D((u_1, u_2)) - B_{cur}}{Best_{CH}(u_1)}
\end{aligned}
\end{equation*}\label{eq:drivingAndCharging}

where $v$ is the speed of the vehicle, $D(u_1, u_2)$ is the distance between vertices $u_1$ and $u_2$, $R_{CO}(v)$ is the consumption rate of the vehicle at the speed $v$, $B_{cur}$ is the current battery capacity of the vehicle and $Best_{CH}(u_1)$ is the charge rate of the best charge station previous to $u_1$ or the charge rate ofs $u_1$.The above equation yields a function on the form: $av^2 + bv + c$, due to the fact that $R_{CO}(v)$ is a quadratic function. $a$ , $b$ and $c$ are some constants which are given by the instance of the vehicle. 
Represented in a Cartesian coordinate system, $T(v,(u_1, u_2)))$ is a parabola, as can be seen in Figure \ref{fig:graph}. On the x-axis is the speed of the vehicle and on the y-axis is the time spent. The turning point of the graph represents the optimal speed to drive at for the given edge, denoted as $v_{opt}(e)$. The point is easily calculated by finding a tangent line with a slope of $0$. If $v_{opt}(e)$ is smaller than $v_{min}(e)$, then $v_{min}(e)$ defines the optimal speed for the edge. Similarly if $v_{opt}(e)$ is larger than $v_{max}(e)$, $v_{max}(e)$ defines the optimal speed for the edge.\\


\begin{figure}[!htb]
\label{fig:graph}
\begin{tikzpicture}
\begin{axis}[xlabel=velocity, ylabel=time,legend style={legend pos=north west}]
\addplot[draw=red,domain=0:200]{(5/x)+(((0.0286*x^2 + 0.4096*x + 107.57)*5)/5000)};
\addlegendentry{$\frac{5}{x}+\frac{(0.029*x^2 + 0.41*x + 107.57)*5}{5000}$}

\addplot[draw=black,domain=25:75]{0.295};
% \addplot[mark=*, domain=25:75] coordinates {(37,295)};
\end{axis}
\end{tikzpicture}% 
\caption{In this instance of $T(v,(u_1, u_2))$, going from $u_1$ to $u_2$, we have a distance of $5 \si{\km}$ and a charge speed of $5 \si{\kW}$ on $u_1$. The optimal speed in this case is $42.12\si{\miles\per\hour}$, which takes roughly 7 minutes to drive}
\end{figure}





While the algorithm progresses through the graph, it need to store a subset of the charge stations on the current path. At every reached charge station, we record the possible energy$B_{possible}$ we can add to the system, defined by $B_{cap}-B_{cur}$ and the charge rate of the station as a tuple: $(B_{possible}, R_{CH}(vertex))$.\\
We maintain a subset of tuples on every vertex by using a list of tuples only with $B_{possible}$ above 0. This will of course always be the case when we reach a charge station, but as we progress through the graph and some distance is being traveled, the possible energy at each previous charge station decreses. The first tuple in the list will always be the the charge station with the best charge rate. A tuple is removed either when $B_{possible}$ hit 0, or when new tuple, with a higher charge rate is found. We make sure to store the best charge station at position 0 in the list, by remove every tuple between the first and second best charge rate in the list.\\

Using this we can define a fastest path algorithm in the following way: \\

\begin{algorithmic}
\Function{GreedyHeuristic}{$RN,s,t,EV$}
	\ForAll{$v \in RN.V$} 
		\State $v.time = \infty$
		\State $v.predecessor = NIL$
		\State $v.preCS = NIL$
		\State $v.B_{cur} = NIL$
	\EndFor
	\State $s.time = 0$
	\State $s.B_{cur} = EV.B_{cur}$

	\State $Q = PriorityQueue$
	\State $INSERT(Q, (s.time, s))$	
	\While{$Q \neq \emptyset$} 
		\State $u = extract-min(Q)$
		\ForAll{each vertex $v \in RN.adj(u)$} 
			\State $time,preCS,B_{cur},energy = travel\_time(RN, u, EV)$
			\If{$v.time > u.time + time$} 
				\State $v.time = u.time + time$
				\State $v.predecessor = u$
				\State $v.B_{cur} = B_{cur}$
				\State $v.preCS = preCS$
				\State $insert(Q, (v.time, v))$	
			\EndIf

		\EndFor
	\EndWhile
	\State \Return $t.time, t.path$
\EndFunction
\end{algorithmic}\label{alg:fastest_path}

