\section{Greedy Heuristic Graph}\label{sec:algo}
In the previous sections we introduced two different approached for solving paths. We are now ready to describe a full algorithm for solving the fastest path problem for an entire road network. 

An approach for solving the full problem, for the whole road network would be to iterate over every single simple path (a path without cycles) in the graph and figure out the best way to travel that path according to either the $travel\_time$ procedure described in Section \ref{sec:greedy} or the Linear Programming model described in Section \ref{sec:LP}. However, doing this would be too complex as the number of simple paths in a graph can be as much as $O(n!)$ which is too expensive.

Instead, one can utilize existing graph algorithms for reducing the number of paths being looked at. e.g. in Dijkstra's algorithm, the number of paths is substantially reduced by relaxing pairs of nodes. This is possible because the shortest path problem has an optimal substructure. Unfortunately the fastest path problem does not have such a substructure, however applying another heuristic to Dijkstra's greedy weight choices, will allow us to build useful paths with charging stations, see Algorithm \ref{alg:fastest_path}.  

Instead of simply relaxing a static weight of edges, we relax the time being calculated by the $travel\_time$ procedure. However this will probably perform poorly by itself, as the time spend charging will skew Dijkstra's algorithm to avoid charging stations, because extra time is added without progressing in the graph. To guarantee that charging stations are used, we prioritise vertices that have charging stations on its predecessor path within driving range of the EV. Imagine that Dijkstra's is at vertex $u_1$ and want to relax vertex $u_2$, $u_1$ has a charging station on its predecessor path, which $u_2$ does not. Even if the weight of $u_1$ is larger than $u_2$, we choose $u_1$ as $u_2$'s predecessor. Note that the Linear Programming solution could theoretically be applied here instead of $travel\_time$.

Alternative greedy choices can be utilised, for instance following time weight alone can work, but the chance that a charging station is on the predecessor paths will be lower. On the other hand more complex greedy choices, for instance where both time, charging stations and potential energy remaining on the charging station or the charge rates of the charging stations is prioritised as well. A more complex greedy choice will likely increase the quality of the paths found and increase the overall performance of the route plans found.


\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{GreedyHeuristic}{$RN,s,t,EV$}
    \ForAll{$v \in RN.V$} 
        \State $v.time = \infty$
        \State $v.predecessor = NIL$
        \State $v.preCS = NIL$
        \State $v.B_{cur} = 0$
    \EndFor
    \State $s.time = 0$
    \State $s.B_{cur} = EV.B_{cur}$

    \State $Q = PriorityQueue$
    \State $insert(Q, (s.time, s))$ 
    \While{$Q \neq \emptyset$} 
        \State $u = extractmin(Q)$
        \ForAll{$v \in RN.adj(u)$} 
            \State $time,preCS,B_{cur},energy = $
            \State $travel\_time(RN, u, v, EV)$
            \If{$v.time > u.time + time$} 
                \State $v.time = u.time + time$
                \State $v.predecessor = u$
                \State $v.B_{cur} = B_{cur}$
                \State $v.preCS = preCS$
                \State $insert(Q, (v.time, v))$ 
            \EndIf
            \If{ $preCS \neq NIL$}
                \State $a$
            \EndIf
        \EndFor
    \EndWhile
    \State \Return $t.time, t.path$
\EndFunction
\end{algorithmic}\label{alg:fastest_path}
\end{algorithm}

\todo[inline]{missing part of algorithm, cant describe more at $preCS \neq NIL$, søg for at alt in beskrivelsen over er i alg. og at alle ikke åbentlyse detaljer i koden beskrives efter}

The worst case running time of the greedy heuristic algorithm is bound by three procedures. First there is the main procedure that is derived directly from Dijkstra's, which has a worst case complexity of $O(|E|+|V|\log|V|)$, with the Fibonacci heap. To that we need to multiply $O(|V|)$ from the $travel\_time$ procedure, as this procedure might go through all vertices, if the vehicle is set to charge at a new charging station for every found edge and every vertex in the graph is also a charging station. Finally we have the procedure that maintain a set of charging stations relevant on each vertex. In the special case where the vehicle have an infinite battery capacity, but start without any battery, and every vertex found happens to be a charging station with a charge rate in a decreasing order, the procedure would have to multiply $O(|V|)$ in the worst case.
However only one of the last two procedure's $O(|V|)$ complexity is added, as the case where the algorithm chose to charge at a new charging station for every edge, never happens with an infinite battery capacity. Likewise the case where the procedure maintains a list of every charging station, never happens if the car has a limited battery capacity. Resulting in a worst case running time of $O(|V||E|+|V^2|\log|V|)$. %http://www.wolframalpha.com/input/?i=v%28e%2Bv*log%28v%29%29

\todo[inline]{wash worst-case section and add LP running time}

In practice Dijkstra's algorithm run faster on a sparse graph, which road networks are, and both of the remaining procedures are simultaneously limited by the fact that only a small amount of charging stations exist and that the EV battery capacity is limited.