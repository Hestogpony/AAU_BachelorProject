\section{Algorithms}
We are now ready to describe a full algorithm for solving the fastest path problem. Being able to solve a path optimal but also heuristically. 

An approach for solving the full problem, for the whole road network would be to iterate over every single simple path(a path without cycles) in the graph and figure out the best way to travel that path according to either the travel\_time procedure described in Section \ref{sec:greedy} or the Linear Programming model described in Section \ref{sec:LP}. However, doing this would be way to complex as the number of simple paths in a graph can be as much as $O(n!)$ which is too much.

Instead one can utilize existing graph algorithms for reducing the number of paths being looked at. e.g. in Dijkstra's algorithm, the number of paths is substantially reduced by relaxing pairs of nodes, effectively reducing the


\begin{algorithmic}
\Function{GreedyHeuristic}{$RN,s,t,EV$}
    \ForAll{$v \in RN.V$} 
        \State $v.time = \infty$
        \State $v.predecessor = NIL$
        \State $v.preCS = NIL$
        \State $v.B_{cur} = 0$
    \EndFor
    \State $s.time = 0$
    \State $s.B_{cur} = EV.B_{cur}$

    \State $Q = PriorityQueue$
    \State $insert(Q, (s.time, s))$ 
    \While{$Q \neq \emptyset$} 
        \State $u = extractmin(Q)$
        \ForAll{$v \in RN.adj(u)$} 
            \State $time,preCS,B_{cur},energy = $
            \State $travel\_time(RN, u, v, EV)$
            \If{$v.time > u.time + time$} 
                \State $v.time = u.time + time$
                \State $v.predecessor = u$
                \State $v.B_{cur} = B_{cur}$
                \State $v.preCS = preCS$
                \State $insert(Q, (v.time, v))$ 
            \EndIf
            \If{ $preCS \neq NIL$}
                \State $a$
            \EndIf
        \EndFor
    \EndWhile
    \State \Return $t.time, t.path$
\EndFunction
\end{algorithmic}\label{alg:fastest_path}

The worst case running time of the greedy heuristic algorithm is bound by three procedures. First there is the main procedure that is derived directly from Dijkstra's, which have a worst case of $O(V^2)$ on dense graphs. To that we need to multiply $O(V)$ from the travel\_time procedure, as this procedure might go through all vertices, if the vehicle is set to charge at a new charging station for every found edge and every vertex in the graph is also a charging station. Finally we have the procedure that maintain a set of charging stations relevant on each vertex. In the special case where the vehicle have an infinitely large battery capacity, but start without any battery, and every vertex found happens to be a charging station with a charge rate in a decreasing order, the procedure would have to multiply $O(V)$ to the worst case.
However only one of the last two procedure's $O(V)$ complexity is added, as the case where the algorithm chose to charge at a new charge station for every edge never happens with an infinity large battery. Likewise the case where the procedure maintain a list of every charging station, never happens if the car has a limited battery capacity. Resulting in a worst case running time of $O(V^3)$.

In practice Dijkstra's algorithm run faster on a sparse graph, which road networks are, and both of the remaining procedures are simultaneously limited from the fact that only a small amount of charging stations exist and that EV battery capacity is limited.
\todo[inline]{need proof-reading}